from langgraph.graph import StateGraph, START, END
from IPython.display import Image, display
from typing_extensions import TypedDict, List, Annotated
import operator
from langchain_openai import AzureChatOpenAI
from pydantic import BaseModel, Field
from langchain_core.messages import HumanMessage, SystemMessage
import os



class Section(BaseModel):
    section_title: str = Field(default=None, description="Title of the Section")
    section_content: str = Field(default=None, description="Brief overview of concept to be covered in this section.")


class sections(BaseModel):
    sections: List[Section] = Field(default=None, description="List of sections for the course outline.")


class State(TypedDict):
    topic: str
    final_report: str
    sections: List[Section]
    completed_sections: Annotated[list, operator.add]
    each_section: Section  # Add this field


planner_llm = llm.with_structured_output(sections)


def generate_outline(state: State):
    outline = planner_llm.invoke(
        f"Generate optimal sections for a report on topic: {state['topic']}. "
        "Please follow report format with introduction, body and conclusion, references etc."
    )
    return {'sections': outline.sections}


def write_report(state: State):
    # Access the section from state
    each_section = state['each_section']
    
    messages = [
        SystemMessage(content=f"Please write a section for the report topic: {state['topic']} "
                              "for the provided title and description. Please do not include preamble "
                              "and use markdown formatting for the report."),
        HumanMessage(content=f"Here is the title of Section: {each_section.section_title} "
                             f"and the description for the Section: {each_section.section_content}. "
                             "Please create the full section")
    ]
    
    report = llm.invoke(messages)
    
    return {'completed_sections': [report.content]}


def synthesizer(state: State):
    """Synthesize full report from sections"""
    
    # List of completed sections
    completed_sections = state["completed_sections"]
    
    # Format completed section to str to use as context for final sections
    completed_report_sections = "\n\n---\n\n".join(completed_sections)
    
    return {"final_report": completed_report_sections}


from langgraph.types import Send


# Conditional edge function to create llm_call workers that each write a section of the report
def assign_workers(state: State):
    """Assign a worker to each section in the plan"""
    
    # Kick off section writing in parallel via Send() API
    return [Send("write_report", {"each_section": s, "topic": state["topic"]}) for s in state["sections"]]


workflow = StateGraph(State)
workflow.add_node("outline_node", generate_outline)
workflow.add_node("write_report", write_report)
workflow.add_node("synthesizer", synthesizer)

workflow.add_edge(START, "outline_node")
workflow.add_conditional_edges(
    "outline_node", assign_workers, ["write_report"]
)
workflow.add_edge("write_report", "synthesizer")
workflow.add_edge("synthesizer", END)

chain = workflow.compile()
result = chain.invoke({"topic": "digital fraud"})


from IPython.display import Markdown
Markdown(result["final_report"])






################################################ ERRORED_ CODE:

from langgraph.graph import START, END, StateGraph
from typing_extensions import TypedDict, Annotated, List
import operator
from pydantic import BaseModel
from langchain_core.messages import HumanMessage, SystemMessage
from langgraph.types import Send


class Section(BaseModel):
    section_title: str = Field(default=None, description="Topic for the section")
    section_content: str = Field(default=None, description="Brief overview of the section to be covered and content/concepts to be covered in this Section")

class sections(BaseModel):
    sections: List[Section] = Field(default=None, description = "List of Sections for the report outline")

class State(TypedDict):
    topic: str
    final_report: str
    sections: List[Section]
    completed_sections: Annotated[List, operator.add]
    each_section: Section



outline_creator = llm.with_structured_output(sections)

def generate_outline(state: State):
    

    outline_prompt=f"Generate outline for the report based on topic {state['topic']}. Please follow formal report writing format like introduction, body, methods, conclusion references etc. Please use markdown formatting for the report."

    outline_content = outline_creator.invoke(outline_prompt)

    return {'sections':outline_content}




def writing_sections(state: State):
    each_section = state['each_section']

    messages = [SystemMessage(f"Write detailed content for the section of the report followed by facts and figure. Topic for the report is {state['topic']} and it should be based on provided on provided title and description available. Please no preamble with each section. Please use Markdown formatting for the report."),
    HumanMessage(f"Here is the title: {each_section.section_title} and description (what has to be covered in this section) : {each_section.section_content}")
    ]

    result = llm.invoke(messages)

    return {'completed_sections': [result.content]}


def jobs_allocator(state:State):
    return [Send("writing_sections", {"each_section": s, "topic": state["topic"]}) for s in state["sections"]]


def synthesizer(state: State):
    all_section = state.get('completed_sections')
    complete_report = "---\n\n---".join(all_section)
    return{'final_report': complete_report}


workflow = StateGraph(State)

workflow.add_node("generate_outline",generate_outline)
workflow.add_node("writing_sections",writing_sections)
workflow.add_node("synthesizer",synthesizer)

workflow.add_edge(START, "generate_outline")
workflow.add_conditional_edges("generate_outline",jobs_allocator, ["writing_sections"])
workflow.add_edge("writing_sections", "synthesizer")
workflow.add_edge("synthesizer", END)


chain = workflow.compile()

result = chain.invoke({"topic":"digital fraud"})

result


Error message: 
Cell In[121], line 43
     39 def writing_sections(state: State):
     40     each_section = state['each_section']
     42     messages = [SystemMessage(f"Write detailed content for the section of the report followed by facts and figure. Topic for the report is {state['topic']} and it should be based on provided on provided title and description available. Please no preamble with each section. Please use Markdown formatting for the report."),
---> 43     HumanMessage(f"Here is the title: {each_section.section_title} and description : {each_section.section_content}")
     44     ]
     46     result = llm.invoke(messages)
     48     return {'completed_sections': [result.content]}

AttributeError: 'tuple' object has no attribute 'section_title'
